# 安卓底层改机分析蓝队 · 半年系统学习路线

> 作者：[人生导师]  
> 使用方式：完成一项就在  `[ ]`  中打  `x` → `[x]`

# Phase 1（第 1–4 周）Android 系统启动 & ART 基础
## 🎯 总体目标

- [ ] 建立 **Android 是操作系统而不是 App** 的整体认知
- [ ] 理解 Android 启动链路及各阶段的可信边界
- [ ] 掌握 Android 进程模型（Zygote / UID / SELinux）
- [ ] 理解 ART 的 dex 加载、编译与 JNI 调用路径

---

## Week 1：Android 启动流程（Boot Chain）

### Day 1：整体启动认知

- [x] 阅读 Android 启动流程官方概览文档
- [x] 理解以下阶段的**职责边界**：
  - [x] BootROM
  - [x] Bootloader
  - [x] Kernel boot.img
- [x] 记录每个阶段：运行环境 / 是否可篡改

### Day 2：init 进程

- [x] 下载 / 浏览 AOSP 源码
- [x] 定位 `system/core/init/main.cpp`
- [x] 理解 init 是如何成为 **PID 1** 的
- [x] 阅读并理解：
  - [x] init.rc
  - [x] service / action 语义

### Day 3：Zygote

- [x] 定位 Zygote 启动入口
- [x] 理解 Zygote 与普通 Linux 进程的区别
- [x] 理解：
  - [x] 为什么 Android 要用 Zygote
  - [x] fork() 在这里解决了什么问题

### Day 4：AVB / dm-verity

AVB 校验 boot 是否篡改
dm-verity 是校验系统层面目录是否篡改

- [x] 阅读 AVB（Android Verified Boot）文档
- [x] 理解 dm-verity 工作原理
- [x] 标注：
  - [x] 哪个阶段校验 Boot
  - [x] 哪个阶段校验 System / Vendor

### Day 5：启动参数与实验

- [x] 使用 emulator 或真机查看启动参数
  - [x] `/proc/cmdline`
- [x] 将参数与启动阶段进行对应

### Day 6：启动链路图（第一次）

- [ ] 绘制启动链路：
  - [ ] BootROM
  - [ ] Bootloader
  - [ ] Kernel
  - [ ] init
  - [ ] Zygote
  - [ ] SystemServer
- [ ] 标记可信 / 不可信边界

### Day 7：周总结

- [ ] 回答问题：
  > 系统完整性在哪些阶段最容易被破坏？
- [ ] 输出 Week 1 总结笔记

---

## Week 2：Android 进程模型 & 安全

### Day 8：Zygote fork 机制

- [x] 跟读 Zygote fork 源码
- [x] 理解 fork 后：
  - [ ] UID 如何分配
  - [ ] 权限如何隔离

### Day 9：UID / GID

- [x] 理解 Android UID 设计
- [x] 区分：
  - [x] system UID
  - [x] app UID

### Day 10：SELinux

- [x] 理解 Android SELinux 模式（Enforcing）
- [x] 阅读 sepolicy 结构
- [x] 使用命令查看：
  - [x] `ps -Z`
  - [x] `ls -Z`

### Day 11：SystemServer

- [x] 理解 SystemServer 的特殊地位
- [x] 阅读 SystemServer 启动流程
- [x] 记录核心服务启动顺序

### Day 12：Binder IPC

- [x] 理解 Binder 的存在意义
- [x] 阅读 Binder 基本调用流程
- [x] 画 IPC 示意图

### Day 13：进程模型总结

- [ ] 总结 Android 进程层级
- [ ] 标注每层安全边界

### Day 14：Week 2 总结

- [ ] 更新启动链路图（加入安全信息）
- [ ] 输出 Week 2 总结笔记

---

## Week 3：ART Runtime 基础

### Day 15：ART 总览

- [ ] 理解 ART 的职责
- [ ] 区分：
  - [ ] Dalvik vs ART

### Day 16：dex / oat / vdex

- [ ] 理解 dex 文件结构
- [ ] 理解 oat / vdex 生成时机
- [ ] 记录三者的关系

### Day 17：Dex 加载流程

- [ ] 阅读 DexFile / OatFile 源码
- [ ] 理解 ClassLoader 加载链

### Day 18：JNI 调用路径

- [ ] 理解 Java → JNI → Native 调用流程
- [ ] 写一个最小 JNI 示例（或阅读现有示例）

### Day 19：解释器 / JIT / AOT

- [ ] 理解解释执行流程
- [ ] 理解 JIT 编译触发条件
- [ ] 理解 AOT 在安装阶段的作用

### Day 20：工具实验

- [ ] 使用 `dexdump`
- [ ] 使用 `oatdump`
- [ ] 分析一个真实 App

### Day 21：Week 3 总结

- [ ] 输出 ART 执行与加载流程总结

---

## Week 4：整合 & 输出

### Day 22：全流程整合

- [ ] 将 ART 加入启动链路图
- [ ] 标注每个阶段的攻击面

### Day 23：系统完整性分析

- [ ] 分析以下阶段的破坏方式：
  - [ ] Bootloader
  - [ ] Kernel
  - [ ] init
  - [ ] Zygote
  - [ ] ART / App

### Day 24：笔记初稿

- [ ] 写阶段总结文章（3–5 页）

### Day 25：图表优化

- [ ] 重画启动链路图（最终版）

### Day 26：技术复盘

- [ ] 不看资料复述完整启动流程

### Day 27：自测

- [ ] 回答核心问题：
  > Android 的信任根在哪里？

### Day 28：Phase 1 完成

- [ ] 整理所有笔记
- [ ] Phase 1 归档完成

---

## ✅ Phase 1 最终产出确认

- [ ] Android 启动链路图（含可信边界）
- [ ] 一篇完整笔记：
  > 系统完整性在哪些阶段最容易被破坏？

# Phase 2（第 5–8 周）Native 基础 & Hook 原理 · 详细任务规划

## 🎯 总体目标

- 从“会用 Frida”升级为“理解 Hook 本质”
- 掌握 ELF 文件结构与 so 加载流程
- 理解并手写 inline hook（ARM64）
- 熟悉 ptrace、maps、auxv 等调试与内存信息
- 对比 Frida inline hook 实现，理解其原理与检测点

---

## Week 5：ELF 文件结构与 so 加载

### Day 29：ELF 文件概述

- 阅读 ELF 文件格式官方文档或《程序员的自我修养》
- 理解 ELF 头部结构
- 理解 Section 与 Segment 的区别
- 使用  `readelf -h`  查看一个 so 文件的头部信息

### Day 30：ELF 程序头与节头

- 理解程序头（Program Header）的作用
- 理解节头（Section Header）的作用
- 使用  `readelf -l`  和  `readelf -S`  分析 so 文件
- 标注 .text、.data、.plt、.got 等关键节的含义

### Day 31：动态链接与重定位

- 理解动态链接的过程
- 理解重定位表（.rel.plt、.rel.dyn）
- 使用  `readelf -r`  查看重定位信息
- 记录动态符号表（.dynsym）与字符串表（.dynstr）的作用

### Day 32：so 加载流程（linker）

- 阅读 Android linker 源码（bionic/linker）
- 理解 so 加载的步骤：
  - 映射文件到内存
  - 解析动态段
  - 执行重定位
  - 运行初始化函数（.init_array）

### Day 33：实验：手动解析 so

- 编写一个简单的 C 程序，使用 mmap 加载 so
- 解析 ELF 头部，打印关键信息
- 理解加载地址与虚拟地址的关系

### Day 34：工具链熟悉

- 使用 objdump 反汇编 so
- 使用 nm 查看符号表
- 使用 strings 查看字符串信息

### Day 35：Week 5 总结

- 绘制 so 加载流程图
- 输出 Week 5 总结笔记

---

## Week 6：Hook 技术原理（上）

### Day 36：Hook 技术分类

- 理解 Hook 的几种方式：
  - Inline Hook
  - PLT/GOT Hook
  - Symbol Hook
  - Trampoline Hook
- 对比各类 Hook 的适用场景与优缺点

### Day 37：ARM64 汇编基础

- 学习 ARM64 基本指令集
- 理解寄存器用途（x0–x30, sp, lr, pc）
- 学习常见指令：mov、ldr、str、bl、ret
- 编写简单的 ARM64 汇编程序（可在线模拟器运行）

### Day 38：Inline Hook 原理

- 理解 Inline Hook 的实现步骤：
  - 备份原指令
  - 写入跳转指令（如：ldr + br）
  - 执行跳转后恢复现场
- 阅读一篇开源的 inline hook 实现（如：Substrate、Dobby）

### Day 39：手写 inline hook（1）

- 编写一个简单的 C 函数（目标函数）
- 编写 hook 函数，打印调用日志
- 使用 mprotect 修改内存页权限
- 实现指令备份与跳转写入

### Day 40：手写 inline hook（2）

- 处理跳转后的现场恢复
- 处理多线程调用场景
- 测试 hook 的稳定性和正确性

### Day 41：PLT/GOT Hook 原理

- 理解 PLT（过程链接表）与 GOT（全局偏移表）的作用
- 理解 PLT/GOT Hook 的实现方式
- 对比与 inline hook 的异同

### Day 42：Week 6 总结

- 输出 inline hook 实现代码与注释
- 绘制 inline hook 与 PLT/GOT hook 对比图
- 输出 Week 6 总结笔记

---

## Week 7：Hook 技术原理（下）与调试接口

### Day 43：Symbol Hook 原理

- 理解符号表与动态符号表
- 理解通过修改符号表实现 hook 的方式
- 使用  `dlopen`、`dlsym`  进行符号解析实验

### Day 44：ptrace 基础

- 理解 ptrace 的作用与使用场景
- 编写一个简单的 ptrace 程序，附加到进程并读取寄存器
- 理解 ptrace 在调试与 hook 中的应用

### Day 45：maps 与 auxv 分析

- 理解  `/proc/self/maps`  的结构与含义
- 编写程序解析 maps，打印内存映射信息
- 理解 auxv（辅助向量）的作用，解析  `/proc/self/auxv`

### Day 46：Frida inline hook 源码分析

- 下载 Frida 源码，定位 gum-arm64-backend
- 阅读其 inline hook 实现逻辑
- 对比自己手写的 inline hook，理解优化点与设计思路

### Day 47：Hook 检测与对抗

- 理解常见的 hook 检测手段：
  - 代码段完整性校验
  - 内存页权限检测
  - 跳转指令模式识别
- 编写一个简单的 hook 检测示例

### Day 48：实验：综合 hook 项目

- 选择一个目标 so 函数（如：strlen）
- 使用 inline hook 或 PLT hook 实现 hook
- 在 hook 函数中打印调用日志
- 测试在不同 Android 版本上的兼容性

### Day 49：Week 7 总结

- 输出 hook 检测与对抗总结笔记
- 输出 Frida inline hook 源码分析笔记
- 输出 Week 7 总结笔记

---

## Week 8：整合输出与面试准备

### Day 50：Hook 技术对比表

- 整理所有学过的 hook 技术
- 制作对比表：

| 技术 | 原理 | 优点 | 缺点 | 检测难度 |
| ---- | ---- | ---- | ---- | -------- |

### Day 51：输出笔记《Android 上所有 Hook 技术的分类与优劣》

- 撰写一篇系统笔记
- 涵盖：
  - 技术原理
  - 实现方式
  - 对抗手段
  - 实际应用场景

### Day 52：面试题准备

- 收集常见面试题：
  - “inline hook 在 ARM64 上如何实现？”
  - “如何检测一个 so 是否被 hook？”
  - “Frida 的 inline hook 是如何实现的？”

### Day 53：实战模拟

- 模拟面试：口述 hook 技术分类与实现
- 模拟面试：解释 ptrace 在 hook 中的作用
- 模拟面试：如何设计一个抗检测的 hook 方案

### Day 54：代码整理与优化

- 整理所有手写代码（ELF 解析、inline hook、maps 解析等）
- 添加注释与 README
- 上传至 GitHub（可选）

### Day 55：阶段复盘

- 不看资料复述：
  - ELF 结构
  - so 加载流程
  - 各类 hook 实现原理

### Day 56：Phase 2 完成

- 整理所有笔记与代码
- 归档 Phase 2 学习资料
- 准备进入 Phase 3

---

## ✅ Phase 2 最终产出确认

- 一篇完整笔记：
  > “Android 上所有 Hook 技术的分类与优劣”
- 手写的 inline hook 代码（ARM64）
- ELF 解析与 maps 解析代码示例
- hook 技术对比表
- 所有周总结笔记归档

# Phase 3（第 9-12 周）Frida / Xposed / Zygisk 深度 · 详细任务规划

## 🎯 总体目标

- 理解  **主流注入框架的架构差异**
- 掌握 Frida 的注入流程与 trace 原理
- 理解 Xposed/LSPosed 的 Zygote 注入与 Method Hook
- 掌握 Zygisk/Riru 的 Magisk 注入链
- 能够从对抗视角分析各框架的检测点与对策

---

## Week 9：Frida 深度解析

### Day 57：Frida 架构总览

- 理解 Frida 的三大组件：
  - frida-server（目标机）
  - frida-core（核心库）
  - frida-python（客户端）
- 安装并配置 Frida 环境（真机/模拟器）
- 运行第一个 Frida 脚本（附到进程并打印模块列表）

### Day 58：frida-server 注入流程（上）

- 阅读 Frida 官方文档，理解注入流程
- 理解 frida-server 如何启动并与客户端通信
- 分析  `frida-server`  的启动参数与工作模式

### Day 59：frida-server 注入流程（下）

- 跟读 frida-core 源码，定位注入相关代码
- 理解注入的几种方式：
  - spawn（启动时注入）
  - attach（附加到运行进程）
- 绘制 frida-server 注入流程图

### Day 60：gum-stalker 动态代码跟踪

- 理解 gum-stalker 的作用与原理
- 阅读 gum-stalker 源码，理解代码插桩机制
- 编写一个简单的 stalker 跟踪示例（跟踪函数调用）

### Day 61：Frida 插桩原理

- 理解 Interceptor、Memory、ApiResolver 等核心模块
- 分析 Frida 如何实现 JavaScript 与 Native 的交互
- 编写一个简单的插桩脚本，监控指定函数的调用

### Day 62：Frida 检测点分析

- 收集常见的 Frida 检测手段：
  - 端口检测（默认 27042）
  - 进程名检测（frida-server）
  - 内存特征检测（gum-js-loop）
  - 文件特征检测（[frida-agent.so](https://frida-agent.so/)）
- 编写一个简单的 Frida 检测脚本

### Day 63：Week 9 总结

- 输出 Frida 架构与注入流程笔记
- 绘制 Frida 检测点思维导图
- 输出 Week 9 总结笔记

---

## Week 10：Xposed / LSPosed 深度解析

### Day 64：Xposed 框架总览

- 理解 Xposed 的工作原理：
  - Zygote 注入
  - Method Hook 机制
- 安装并配置 Xposed 环境（模拟器）
- 编写一个简单的 Xposed 模块（Hook 系统方法）

### Day 65：Xposed 的 Zygote 注入点

- 阅读 Xposed 源码，定位 Zygote 注入相关代码
- 理解 Xposed 如何修改 app_process 以加载 Xposed 模块
- 绘制 Xposed 在 Zygote 启动过程中的注入时机图

### Day 66：Method Hook 原理（上）

- 理解 Java 方法的结构与调用机制
- 分析 Xposed 的 Method Hook 实现：
  - 方法替换原理
  - 参数与返回值处理
- 跟读 XposedBridge 源码，理解 Hook 流程
- 理解 ArtMethod 结构
- 分析 Xposed 如何修改 ArtMethod 以实现 Hook
- 对比不同 Android 版本下 ArtMethod 的差异

### Day 68：LSPosed 架构演进

- 理解 LSPosed 与 Xposed 的关系与差异
- 分析 LSPosed 的模块化设计
- 理解 LSPosed 如何解决 Xposed 的某些问题（如性能、稳定性）

### Day 69：Xposed/LSPosed 检测点分析

- 收集常见的 Xposed 检测手段：
  - 类加载器检测（XposedBridge）
  - 方法栈检测（调用栈分析）
  - 文件系统检测（xposed.prop）
- 编写一个简单的 Xposed 检测脚本

### Day 70：Week 10 总结

- 输出 Xposed/LSPosed 架构与 Hook 原理笔记
- 绘制 Xposed 检测点思维导图
- 输出 Week 10 总结笔记

---

## Week 11：Zygisk / Riru 深度解析

### Day 71：Magisk 与 Zygisk 关系

- 理解 Magisk 的基本原理（systemless root）
- 理解 Zygisk 的作用与定位（Zygote 注入模块）
- 安装并配置 Magisk + Zygisk 环境

### Day 72：Zygisk 注入链分析（上）

- 阅读 Zygisk 源码，理解其注入流程
- 分析 Zygisk 如何通过 Magisk 注入到 Zygote
- 理解 Zygisk 的模块加载机制

### Day 73：Zygisk 注入链分析（下）

- 对比 Zygisk 与 Riru 的注入差异
- 理解 Zygisk 为什么更隐蔽（注入时机、方式）
- 绘制 Zygisk 注入链与模块加载流程图

### Day 74：Riru 架构与演进

- 理解 Riru 的工作原理（替换 libmemtrack）
- 分析 Riru 的注入流程与模块机制
- 对比 Riru 与 Zygisk 的优缺点

### Day 75：Zygisk 模块开发

- 编写一个简单的 Zygisk 模块
- 实现一个简单的功能（如：拦截某个系统调用）
- 测试模块的加载与功能

### Day 76：Zygisk/Riru 检测点分析

- 收集常见的 Zygisk/Riru 检测手段：
  - 进程内存映射检测（zygisk、riru）
  - 系统属性检测（ro.dalvik.vm.native.bridge）
  - 模块文件检测
- 编写一个简单的 Zygisk 检测脚本

### Day 77：Week 11 总结

- 输出 Zygisk/Riru 架构与注入原理笔记
- 绘制 Zygisk 检测点思维导图
- 输出 Week 11 总结笔记

---

## Week 12：对抗视角综合分析与输出

### Day 78：三大框架对比分析

- 制作对比表：

| 框架 | 注入时机 | 注入方式 | Hook 粒度 | 可检测点 | 蓝队对策 |
| ---- | -------- | -------- | --------- | -------- | -------- |
|      |          |          |           |          |          |

### Day 79：对抗技术深度分析

- 分析各框架的对抗手段：
  - 如何隐藏进程
  - 如何绕过端口检测
  - 如何消除内存特征
- 阅读相关开源对抗项目（如：Frida 反检测脚本）

### Day 80：检测方案设计

- 设计一个组合检测方案：
  - 静态检测（文件、属性）
  - 动态检测（行为、内存）
  - 运行时检测（调用栈、异常）
- 编写一个综合检测脚本（可检测 Frida/Xposed/Zygisk）

### Day 81：蓝队对策思考

- 针对每个框架，思考蓝队对策：
  - 如何在不影响用户体验的情况下检测
  - 如何实现灰度上线与演进
  - 如何降低误报率

### Day 82：面试题准备

- 收集常见面试题：
  - “Frida 和 Xposed 在架构上有什么本质区别？”
  - “Zygisk 为什么比 Riru 更隐蔽？”
  - “如何设计一个可演进的注入框架检测方案？”

### Day 83：实战模拟

- 模拟面试：口述三大框架的架构差异
- 模拟面试：解释 Zygisk 的注入链
- 模拟面试：设计一个 Frida 检测方案并保证可演进

### Day 84：Phase 3 完成

- 整理所有笔记、代码与图表
- 归档 Phase 3 学习资料
- 准备进入 Phase 4

---

## ✅ Phase 3 最终产出确认

- 对比表:

| 框架 | 注入时机 | 可检测点 | 蓝队对策 |
| ---- | -------- | -------- | -------- |
|      |          |          |          |

- 三大框架的架构分析笔记（Frida、Xposed/LSPosed、Zygisk/Riru）
- 综合检测脚本（可检测多种注入框架）
- 各框架检测点思维导图
- 所有周总结笔记归档

# Phase 4（第 13-16 周）改机 / 虚拟化 / 模拟环境识别 · 详细任务规划

## 🎯 总体目标

- 形成  **改机手段的完整分类体系**
- 掌握主流改机技术原理（从属性修改到内核层）
- 理解虚拟化环境（云手机/VMOS）与模拟环境（unidbg）的工作原理
- 建立多维度环境一致性检测模型（硬件、行为、环境）
- 能够系统化阐述“为什么单点检测必然失败”

---

## Week 13：改机技术原理与分类（上层）

### Day 85：改机技术总览与分类

- 建立改机分类体系：
  - 应用层改机（App）
  - 框架层改机（Framework Hook）
  - 系统属性层改机（build.prop）
  - 硬件抽象层改机（Native HAL）
  - 内核层改机（Kernel/ROM）
- 分析各类改机的影响范围和所需权限

### Day 86：build.prop 属性篡改

- 理解  `build.prop`  文件的作用与结构
- 分析常见篡改属性（如：ro.build.fingerprint, ro.product.model）
- 实验：使用 Magisk 模块或 root 权限修改  `build.prop`  并验证
- 思考检测手段：如何区分官方属性与篡改属性？

### Day 87：系统服务与 Framework Hook

- 理解 Android 系统服务（如：ActivityManagerService）如何提供设备信息
- 分析通过 Hook 系统服务方法（如：`getDeviceId`）实现改机的原理
- 实验：编写一个 Xposed/LSPosed 模块，Hook `android.os.Build`  类的方法并返回虚假信息
- 记录该方式的检测特征（如：调用栈异常、方法字节码校验）

### Day 88：应用层改机分析

- 研究典型改机 App 的工作原理（如：某型号修改器）
- 分析其使用的技术组合（可能包括：root、Xposed、直接文件修改）
- 思考检测手段：如何识别设备上安装的改机 App 或相关模块？

### Day 89：硬件抽象层（HAL）与传感器

- 理解 HAL 层的作用，尤其是传感器 HAL
- 分析如何通过注入或替换 HAL 库（如：`libsensors.so`）伪造传感器数据
- 思考检测手段：传感器数据是否具有物理合理性（如：加速度、陀螺仪）？

### Day 90：周整合与检测视角（一）

- 汇总本周学习的改机技术，按“层”整理成表格
- 为每种技术列举至少一种理论上的检测思路
- 输出笔记：“上层改机（应用至 HAL）的常见手段与对抗初探”

### Day 91：Week 13 总结

- 绘制“上层改机技术栈”图谱
- 输出 Week 13 总结笔记

---

## Week 14：内核层改机与虚拟化环境

### Day 92：内核层改机原理

- 理解内核模块（.ko）与系统调用（syscall）的概念
- 分析如何通过内核模块或修改内核源码来篡改系统底层信息（如：`/proc/cpuinfo`）
- 了解 boot.img 解包、修改与重打包的基本流程

### Day 93：ROM 定制与刷机

- 理解 Android ROM 的构成（boot, system, vendor, recovery）
- 分析定制 ROM 如何预置改机功能（如：修改默认  `build.prop`，集成 Magisk）
- 实验：下载一个开源 ROM（如 LineageOS）源码，尝试修改一个设备属性并编译

### Day 94：虚拟化环境（一）- 云手机

- 理解云手机架构（云端真机 vs 虚拟化容器）
- 分析其与本地真机的关键差异点：
  - 硬件信息（IMEI, Serial）的生成与管理方式
  - 网络拓扑与 IP 地址
  - 传感器模拟的逼真度

### Day 95：虚拟化环境（二）- VMOS 类虚拟机

- 分析 VMOS 等“安卓虚拟机内运行安卓”的原理
- 理解其与云手机的技术差异（本地虚拟化 vs 云端）
- 实验（可选）：在真机上安装 VMOS 应用，观察其创建的虚拟环境特征

### Day 96：模拟执行环境 - unidbg

- 理解 unidbg 等模拟执行框架的原理与用途
- 分析在 unidbg 中运行 App 代码或 SO 库时，环境信息（设备、文件系统）的来源与伪造方式
- 思考检测手段：如何识别代码运行在模拟器而非真实 ART 环境？

### Day 97：周整合与检测视角（二）

- 对比各类虚拟化/模拟环境（云手机、VMOS、unidbg）在实现层级上的差异
- 输出笔记：“底层改机与虚拟化环境剖析”

### Day 98：Week 14 总结

- 绘制“内核与虚拟化攻击面”思维导图
- 输出 Week 14 总结笔记

---

## Week 15：环境一致性检测体系构建

### Day 99：硬件一致性检测

- 收集可用于硬件指纹的信息源：
  - `/proc/cpuinfo`, `/proc/meminfo`
  - 传感器列表与数据（SensorManager）
  - Battery, Telephony 相关信息
- 编写一个信息收集脚本，并思考如何判断其“一致性”（如：传感器数量是否符合该型号常态？）

### Day 100：行为一致性检测

- 理解“行为指纹”概念：
  - 系统调用（syscall）序列或时序分析
  - 文件 I/O 行为特征
  - 进程间通信（如 Binder）调用模式
- 分析虚拟化/模拟环境在行为上可能露出的马脚（如：syscall 实现不完整、时序异常）

### Day 101：环境一致性检测（一）- Binder

- 深入理解 Binder 驱动与 ServiceManager
- 分析如何检测 Binder 环境异常：
  - 关键系统服务（如  `service list`  输出）是否完整、正确？
  - Binder 通信的延迟或错误码是否有异常模式？

### Day 102：环境一致性检测（二）- 综合维度

- 整合硬件、行为、环境（Binder/Service）多个维度的检测指标
- 设计一个简单的“环境风险评分模型”雏形（例如：每个异常维度加权计分）
- 思考如何降低误报（如：区分老旧真机与虚拟机的传感器缺失）

### Day 103：对抗与绕过分析

- 从攻击者视角思考：如何绕过上述多维度的检测？
  - 更完美的硬件信息伪造
  - 模拟更真实的系统调用行为
  - 完整实现 Binder 服务
- 理解“道高一尺，魔高一丈”的持续对抗本质

### Day 104：实验：编写一个基础检测 PoC

- 选择一个具体目标（如：检测 VMOS 或 unidbg 环境）
- 在真实环境和目标环境中测试，分析结果

### Day 105：Week 15 总结

- 输出“环境一致性检测指标体系”文档
- 输出检测 PoC 代码及测试报告
- 输出 Week 15 总结笔记

---

## Week 16：体系化思维整合与输出

### Day 106：系统文档撰写 - 核心论点

- 撰写系统文档的核心部分：“为什么单点检测必然失败？”
- 论述要点：
  - 攻击面广泛（从应用到内核）
  - 对抗技术持续演进（静态 → 动态 → 行为伪造）
  - 单一维度的信息容易被完美伪造

### Day 107：系统文档撰写 - 解决方案

- 在文档中提出体系化解决方案：
  - 多维信息交叉验证
  - 行为时序分析
  - 风险聚合与评分
  - 持续的策略迭代与机器学习应用可能

### Day 108：构建完整的改机对抗知识体系

- 绘制一张涵盖所有 Phase 4 内容的“改机与检测全景图”
  - 攻击树：展示从上层到内核的各类改机路径
  - 防御网：展示从硬件到行为的各类检测锚点
  - 标注关键对抗节点

### Day 109：面试题深度准备

- 收集并回答高阶面试题：
  - “请详细描述你如何设计一套能有效识别改机设备的方案？”
  - “云手机和真机在 Binder 通信层面可能会有哪些可检测的差异？”
  - “如果攻击者能够完美模拟所有硬件信息和静态行为，我们还能从哪些维度进行检测？”

### Day 110：模拟架构设计评审

- 扮演蓝队架构师，向“面试官”阐述你的环境安全检测架构设计
  - 技术选型与理由
  - 核心检测逻辑流程图
  - 如何平衡检出率、性能与用户体验

### Day 111：最终输出物整合

- 将系统文档、全景图、检测 PoC 代码、面试题解答等所有产出物进行整理
- 确保文档结构清晰，图表可读性强

### Day 112：Phase 4 完成与复盘

- 不看资料，复述改机技术的完整分类
- 复述环境一致性检测的三个核心维度及其原理
- 归档 Phase 4 所有学习资料与产出
- 准备进入 Phase 5

---

## ✅ Phase 4 最终产出确认

- 一篇系统文档：
  > “为什么单点检测必然失败？”（需包含攻击面分析与防御体系设计）
- 改机与检测全景图（攻击树+防御网）
- 环境一致性检测指标体系文档
- 一个基础的改机环境检测 PoC 脚本
- 所有周总结笔记归档

# Phase 5（第 17-20 周）Kernel / SELinux / 系统完整性 · 详细任务规划

## 🎯 总体目标

- 建立  **Android Kernel 基础架构认知**
- 深入理解  **SELinux 策略机制与绕过方式**
- 掌握  **系统完整性保护机制**（dm-verity/AVB）及其攻击面
- 能够绘制  **Magisk 绕过系统完整性的完整路径图**
- 具备  **内核层安全事件分析与防护方案设计**  能力

---

## Week 17：Android Kernel 基础与攻击面

### Day 113：Android Kernel 架构概述

- 理解 Android Kernel 与主线 Linux Kernel 的关系
- 掌握 Android 特有的内核驱动与子系统：
  - Binder
  - ashmem
  - wakelocks
  - lowmemorykiller
- 阅读 Android Kernel 官方文档，了解其安全增强特性

### Day 114：内核模块与系统调用

- 理解内核模块（.ko）的加载机制
- 学习系统调用（syscall）的工作原理
- 实验：编写一个简单的内核模块，打印“Hello Kernel”
- 思考：内核模块如何被用于 rootkit 或隐藏恶意行为？

### Day 115：procfs 与 sysfs 深入

- 理解  `/proc`  和  `/sys`  文件系统的作用
- 分析关键文件：
  - `/proc/kallsyms`（内核符号表）
  - `/proc/modules`（已加载模块）
  - `/sys/class`（设备类信息）
- 编写一个程序，遍历  `/proc`  下各进程的信息并解析关键字段

### Day 116：内核调试基础

- 学习使用  `dmesg`  查看内核日志
- 理解  `printk`  日志级别
- 配置内核  `CONFIG_DEBUG_KERNEL`  等调试选项（模拟器环境）
- 实验：在内核模块中添加  `printk`  日志，观察输出

### Day 117：内核漏洞类型初探

- 学习常见内核漏洞类型：
  - 内存破坏（堆溢出、UAF）
  - 权限提升（提权漏洞）
  - 信息泄漏
- 阅读一篇公开的 Android 内核 CVE 分析报告（如：CVE-2020-0041）
- 理解漏洞利用与防护的基本思路

### Day 118：内核安全机制

- 了解内核安全机制：
  - KASLR（内核地址空间布局随机化）
  - PAN/PXN（特权执行保护）
  - CFI（控制流完整性）
- 思考：这些机制如何增加漏洞利用难度？

### Day 119：Week 17 总结

- 输出 Android Kernel 基础架构笔记
- 绘制内核模块加载与系统调用流程图
- 输出 Week 17 总结笔记

---

## Week 18：SELinux 深度解析

### Day 120：SELinux 基础概念

- 理解 SELinux 的三种运行模式（Disabled, Permissive, Enforcing）
- 掌握核心概念：
  - Subject（主体）
  - Object（客体）
  - Action（操作）
  - Policy（策略）
- 实验：切换 SELinux 模式（`setenforce 0/1`），观察对系统的影响

### Day 121：SELinux 策略语言

- 学习 SELinux 策略文件结构（.te, .sepolicy）
- 理解策略规则语法：
  - allow, deny, auditallow, dontaudit
  - type, attribute, class, permission
- 实验：编写一个简单的  `.te`  文件，允许一个测试应用访问某个设备节点

### Day 122：SELinux 策略编译与加载

- 理解策略编译工具（`checkpolicy`, `sepolicy-inject`）
- 了解策略加载机制（`load_policy`）
- 实验：编译自定义策略文件并加载到设备

### Day 123：SELinux 在 Android 中的实现

- 分析 Android SELinux 策略文件位置：
  - `/system/etc/selinux`
  - `/vendor/etc/selinux`
- 理解  `neverallow`  规则的作用
- 阅读 AOSP 中 SELinux 策略的编译脚本

### Day 124：SELinux 绕过技术分析

- 分析常见绕过方式：
  - 修改启动参数（`androidboot.selinux=permissive`）
  - 替换策略文件（需 root 权限）
  - 内核漏洞利用（直接修改内核中的 SELinux 状态）
- 研究 Magisk 如何在不破坏 dm-verity 的情况下绕过 SELinux

### Day 125：SELinux 审计日志分析

- 学习使用  `dmesg | grep avc`  或  `logcat | grep avc`  查看 SELinux 拒绝日志
- 理解 AVC 日志的结构与含义
- 实验：触发一个 SELinux 拒绝事件，分析日志并编写策略规则修复

### Day 126：Week 18 总结

- 输出 SELinux 策略分析与绕过技术笔记
- 绘制 SELinux 策略加载与执行流程图
- 输出 Week 18 总结笔记

---

## Week 19：系统完整性机制深度分析

### Day 127：dm-verity 工作原理

- 理解 dm-verity 的数据结构（哈希树）
- 分析 dm-verity 的验证流程（块级验证）
- 实验：在模拟器上启用 dm-verity，观察其行为
- 思考：攻击者如何绕过 dm-verity？（如：修改 initramfs、内核漏洞）

### Day 128：AVB（Android Verified Boot）2.0

- 理解 AVB 2.0 的启动验证链（boot → vbmeta → system/vendor）
- 掌握关键概念：
  - 启动链（chain of trust）
  - 回滚保护（rollback protection）
  - 设备状态（LOCKED/UNLOCKED）
- 分析  `vbmeta.img`  的结构与作用

### Day 129：启动完整性攻击面分析

- 分析启动链各阶段的攻击面：
  - Bootloader 解锁漏洞
  - 内核漏洞（绕过 dm-verity）
  - initramfs 篡改
- 阅读相关研究论文或博客（如：Verified Boot 绕过技术）

### Day 130：Magisk 系统完整性绕过剖析

- 深入分析 Magisk 的工作原理：
  - systemless 设计哲学
  - boot image 修补流程
  - 如何保持 dm-verity 与 AVB 验证通过
- 绘制 Magisk 从启动到系统初始化的完整路径图

### Day 131：其他完整性绕过技术

- 分析其他 root 方案（如：SuperSU、KernelSU）的绕过方式
- 研究基于内核漏洞的完整性绕过（如：dirtypipe）
- 对比各类方案的隐蔽性与兼容性

### Day 132：完整性检测与防护

- 设计内核完整性检测方案：
  - 内核代码段校验
  - 系统调用表监控
  - 模块签名验证
- 思考：如何在用户态实现有效的内核完整性监控？

### Day 133：Week 19 总结

- 输出系统完整性机制与绕过综合分析笔记
- 绘制  **Magisk 绕过系统完整性的完整路径图**
- 输出 Week 19 总结笔记

---

## Week 20：综合实战与输出

### Day 134：内核安全事件分析模拟

- 给定一个内核安全事件场景（如：可疑内核模块加载）
- 制定分析步骤：
  - 日志分析（dmesg, audit）
  - 内存分析（/proc/kcore, /dev/mem）
  - 网络与进程行为关联
- 撰写模拟分析报告

### Day 135：SELinux 策略强化设计

- 为一个敏感应用（如：支付应用）设计强化的 SELinux 策略
- 遵循最小权限原则
- 考虑兼容性与性能影响
- 编写策略文件并测试

### Day 136：系统完整性监控 PoC

- 设计并实现一个简单的完整性监控 PoC：
  - 监控  `/system`  关键文件的哈希值
  - 检测 SELinux 状态是否被篡改
  - 报警机制（日志或网络上报）
- 在模拟器或测试机上运行

### Day 137：面试题深度准备

- 收集并回答高级面试题：
  - “请解释 Android 启动链中的完整性保护，以及攻击者可能从哪些环节突破？”
  - “SELinux 的 neverallow 规则被违反意味着什么？如何调查？”
  - “如何检测设备是否安装了 Magisk 等 systemless root 方案？”
  - “如果你设计一个内核级 rootkit，如何躲避现有的检测机制？”

### Day 138：架构设计：内核层安全防护方案

- 设计一个完整的内核层安全防护方案：
  - 防护目标（完整性、机密性、可用性）
  - 技术组件（模块签名、系统调用拦截、审计日志增强）
  - 部署与运维考虑（性能影响、OTA 兼容性）
- 绘制方案架构图

### Day 139：最终输出物整合

- 整理所有产出：
  - Magisk 绕过路径图
  - 内核安全分析报告模板
  - SELinux 策略设计范例
  - 完整性监控 PoC 代码
- 确保文档与代码的完整性与可读性

### Day 140：Phase 5 完成与复盘

- 不看资料，复述 Android 系统完整性保护的核心机制
- 复述 SELinux 策略的编译、加载与执行流程
- 复述内核漏洞利用与防护的基本原理
- 归档 Phase 5 所有学习资料与产出
- 准备进入最后的  **Phase 6**

---

## ✅ Phase 5 最终产出确认

- 绘制  **Magisk 绕过系统完整性的完整路径图**
- Android Kernel 安全机制分析笔记
- SELinux 策略深度解析与绕过技术文档
- 系统完整性监控 PoC 代码
- 内核安全事件分析模拟报告
- 所有周总结笔记归档

# Phase 6（第 21-24 周）蓝队检测设计 & 面试准备 · 详细任务规划

## 🎯 总体目标

- 从技术执行者升级为  **防御体系设计者**
- 掌握  **组合检测设计**  与  **风险评分模型**  构建能力
- 具备  **检测方案灰度上线**  与  **误杀控制**  的工程思维
- 完成  **个人蓝队技术手册**  和  **简历项目重构**，做好面试准备
- 能够清晰阐述  **可演进的安全检测架构**  设计理念

---

## Week 21：组合检测设计与风险建模基础

### Day 141：防御设计思维转换

- 阅读经典安全防御体系文章（如：纵深防御、零信任）
- 思考从“单点检测”到“体系化防御”的思维转变
- 撰写笔记：分析一个已知安全产品（如：某厂商安全 SDK）的防御设计思路

### Day 142：组合检测设计原则

- 学习组合检测的核心原则：
  - 冗余性（多维度验证）
  - 层次性（从应用到内核）
  - 动态性（行为+静态）
- 分析 Phase 4 的环境一致性检测，思考如何进一步组合强化

### Day 143：检测点权重与评分模型（一）

- 理解风险评分的基本概念：如何将不同检测结果量化为一个风险分数
- 学习简单的加权评分模型
- 为一个虚拟场景（如：设备篡改检测）设计一个包含 3 个检测维度的评分模型雏形

### Day 144：检测点权重与评分模型（二）

- 深入理解如何确定权重：
  - 基于攻击成功率
  - 基于绕过难度
  - 基于误报影响
- 为你的评分模型雏形设定初步权重，并解释理由

### Day 145：实验：实现一个简单评分引擎

- 编写一个 Python 脚本，模拟接收多个检测结果（布尔值或置信度）
- 根据权重计算总风险分数
- 实现简单的阈值判断（如：>70 分触发告警）

### Day 146：灰度发布与渐进式策略

- 理解灰度发布在安全检测中的重要性
- 设计一个检测策略的灰度上线方案：
  - 如何选择初始用户群体（如：按设备型号、地区）
  - 如何收集反馈（误报、性能）
  - 如何定义发布成功标准并全量

### Day 147：Week 21 总结

- 输出组合检测设计原则笔记
- 输出风险评分模型设计文档（含权重设定逻辑）
- 输出简单评分引擎代码
- 输出 Week 21 总结笔记

---

## Week 22：高级检测策略与稳定性保障

### Day 148：行为建模与异常检测

- 学习基础的行为建模概念（白名单 vs 黑名单，基线建模）
- 分析 Android 应用或系统服务中可用于行为建模的维度（如：API 调用序列、文件访问模式）
- 设计一个针对“异常进程启动”的简单行为检测规则

### Day 149：对抗样本与检测绕过思考

- 从攻击者视角出发，思考如何绕过你设计的组合检测体系
- 分析对抗样本在安全检测中的应用（如：对抗机器学习模型）
- 撰写笔记：列举三种可能的绕过方式及应对思路

### Day 150：稳定性与误杀控制（一）

- 深入分析误杀的根源：
  - 设备/ROM 碎片化
  - 厂商定制行为
  - 正常软件的“可疑”行为
- 学习误杀控制的基本方法：白名单、置信度调整、二次验证

### Day 151：稳定性与误杀控制（二）

- 设计一个误杀处理流程：
  - 如何收集误报样本（用户反馈、自动化监控）
  - 如何分析误报根因
  - 如何更新检测策略（规则/模型迭代）
- 绘制误杀处理闭环流程图

### Day 152：性能影响评估与优化

- 思考检测逻辑对应用性能（启动时间、CPU、内存、电量）的影响
- 学习性能评估的基本方法（插桩、profiling）
- 为你的检测方案设计一个轻量级性能测试用例（如：检测逻辑执行耗时）

### Day 153：可演进架构设计

- 学习可演进安全架构的关键要素：
  - 配置化（动态更新检测规则/模型参数）
  - 插件化（灵活增减检测模块）
  - 数据驱动（检测策略基于线上数据持续优化）
- 绘制一个可演进检测系统的简要组件图

### Day 154：Week 22 总结

- 输出行为检测规则设计文档
- 输出误杀控制流程文档
- 输出可演进检测系统架构图
- 输出对抗绕过分析与应对笔记
- 输出 Week 22 总结笔记

---

## Week 23：面试准备与项目深度重构

### Day 155：面试题系统梳理（一）

- 按技术领域梳理潜在面试题：
  - Android 系统与安全基础
  - Hook/注入/改机对抗
  - 内核/SELinux/完整性
  - 蓝队检测设计
- 为每个领域准备  **2-3 个核心问题**  的详细答案（口述版本）

### Day 156：面试题系统梳理（二）

- 准备  **系统设计类**  问题：
  - “如何设计一个 Frida 检测方案并保证其可演进？”
  - “蓝队检测如何灰度上线并控制误杀？”
  - “请设计一个针对云手机的识别方案。”
- 为每个问题准备回答框架（问题分解、设计原则、技术选型、演进考虑）

### Day 157：模拟面试 - 技术深度

- 自我模拟或找同伴进行技术深度面试
- 重点考察对底层原理的理解（如：Zygote 注入的多种方式及差异）
- 录制回答过程，复盘表达是否清晰、逻辑是否严谨

### Day 158：模拟面试 - 系统设计

- 进行系统设计模拟面试
- 练习在白板或绘图工具上边画边讲设计方案
- 重点关注是否能从需求分析、架构设计到落地细节进行完整阐述

### Day 159：简历项目重构（一）

- 重新审视整个学习路线中的所有实验和产出
- 挑选  **3 个最具代表性**  的项目进行深度重构：
  1. **底层分析类**（如：ART 加载流程分析、Hook 原理实现）
  2. **攻防对抗类**（如：Frida/Xposed 检测脚本）
  3. **体系设计类**（如：环境一致性检测 PoC、风险评分模型）
- 为每个项目撰写详细的背景、挑战、解决方案、个人贡献与结果描述

### Day 160：简历项目重构（二）

- 使用  **STAR 法则**（情境、任务、行动、结果）优化项目描述
- 量化成果（如：检测准确率提升 X%，误报率降低 Y%）
- 将项目更新至简历，确保技术关键词突出，角色职责明确

### Day 161：Week 23 总结

- 输出面试题与答案集（按领域分类）
- 输出系统设计问题回答框架文档
- 输出更新后的简历（可隐藏个人信息）
- 输出 Week 23 总结笔记

---

## Week 24：最终整合输出与终极复盘

### Day 162：个人蓝队技术手册撰写（一）- 开篇与架构

- 确定技术手册的受众与目标
- 撰写手册开篇：阐述 Android 蓝队工作的价值与挑战
- 整理手册目录，建立清晰的层级结构

### Day 163：个人蓝队技术手册撰写（二）- 核心技术章节

- 将 Phase 1-5 的核心学习成果，转化为手册的技术章节
- 每章节应包含：原理简述、攻击面分析、检测思路、对抗演进思考
- 融入自己的实践心得与图表（如：启动流程图、Hook 对比表、绕过路径图）

### Day 164：个人蓝队技术手册撰写（三）- 防御体系设计章节

- 撰写核心章节：**体系化蓝队检测设计**
- 内容涵盖：组合检测、风险建模、误杀控制、灰度发布、可演进架构
- 加入一个完整的设计案例（如：设计一个改机设备识别系统）

### Day 165：个人蓝队技术手册定稿与美化

- 通读全文，检查技术准确性、逻辑连贯性与语言流畅性
- 插入必要的图表、代码片段，增强可读性
- 进行排版，考虑输出为  **PDF**  或发布为  **系列博客文章**

### Day 166：终极模拟面试与复盘

- 进行一次最接近真实场景的终极模拟面试（涵盖技术、设计、行为问题）
- 邀请有经验的朋友或前辈担任面试官（如果可能）
- 深度复盘，查漏补缺，调整心态和表达策略

### Day 167：学习路线总复盘与未来规划

- 回顾半年学习历程，总结最大的收获与成长
- 反思不足与待深入的方向
- 规划后续学习路径（如：深入研究内核安全、拓展 iOS/鸿蒙、学习威胁情报）

### Day 168：Phase 6 完成与庆祝

- 确认所有最终产出物已完成并归档
- 将技术手册、更新后的简历等材料整理至专用文件夹
- **庆祝！**  你已经完成了一个系统性的、高强度的学习计划。

---

## ✅ Phase 6 最终产出确认

- **个人蓝队技术手册（PDF / Blog）** - 体系化的知识输出
- **简历项目重构（偏防御）** - 聚焦蓝队能力的更新简历
- **组合检测与风险评分模型设计文档**
- **可演进检测系统架构图**
- **面试题库与系统设计回答框架**
- **所有阶段的学习笔记、代码、图表完整归档**

---

## 🎉 恭喜完成

**后续行动建议：** 2. **建立影响力**：将你的技术手册发布在知乎、掘金、安全客等平台，建立个人品牌。 3. **持续学习**：安全攻防是持续对抗的过程，保持对新技术、新攻击手法的关注。 4. **横向拓展**：可将此知识体系延展到 iOS、HarmonyOS 或其他移动平台。
**祝你求职顺利，在蓝队防御的道路上不断精进！**
